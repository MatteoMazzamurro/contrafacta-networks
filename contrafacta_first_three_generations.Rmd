---
title: "Contrafacta in the First Three Troubadour Generations"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'contrafacta_first_three_generations.html'))})
author: "Matteo Mazzamurro"
date: "21 febbraio 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R Markdown allows to reproduce the results from the article "Temporal Networks of Contrafacta in the First Three Troubadour Generations" by Stefano Milonia and Matteo Mazzamurro. All data can be found in the appropriate folder in the same GitHub project. The code is structured as follows:

0. Packages

1. Data 

2. Network of Songs

3. Networks of Authors

##0. Packages

A number of R packages are necessary for the smooth running of the code. The fundamental package is the "tsna" (Skye Bender-deMoll and Martina Morris (2021). tsna : Tools for Temporal Social Network Analysis. R package version 0.3.5. http://statnet.org/). 
```{r}
#network packages
  library(sna)
  library(tsna)
  library(tidyverse)
  library(igraph)
  library(network)
  library(networkDynamic)
  library(visNetwork)
  library(ndtv)
  #data cleaning
  library(plyr)
  library(dplyr)
  #visuals
  library(ggplot2)
  library(ggrepel)
  library(hrbrthemes)
  library(ggpubr)
```

##1. Data 
The raw data is taken from the Bibliografia Elettronica dei Trovatori (Asperti, S. and de Nigro, L. (2012). Bibliografia Elettronica dei Trovatori -- v. 2-5-2012. Available at: http://www.bedt.it/BEdT_04_25/). The data has been checked to ensure it is temporally consistent and can be used to construct temporal networks.
```{r}
contrafacta_and_analogies_with_dates<-read.csv("./data/contrafacta_and_analogies_with_dates.csv",sep=",",stringsAsFactors=FALSE)
```

##2. Network of Songs

First construct dataframes of the links and node in the network. Links from a model song to a contrafactum are directed and are shown as solid arrows. Links between songs with metrical analogies are bidirectional and shown as dashed arrows. 
```{r}
  #contrafacta links
  contrafacta<-data.frame(
    "from"=contrafacta_and_analogies_with_dates$model_id,
    "to"=contrafacta_and_analogies_with_dates$contrafactum_id,
    "title"=paste(contrafacta_and_analogies_with_dates$model_id,"-->",contrafacta_and_analogies_with_dates$contrafactum_id))
  contrafacta<-na.omit(contrafacta)
  contrafacta<-distinct(contrafacta)
  contrafacta$dashes<-FALSE
  contrafacta$arrows<-"to"
  
  #metrical analogies links
  analogies<-data.frame(
    "from"=contrafacta_and_analogies_with_dates$model_id,
    "to"=contrafacta_and_analogies_with_dates$metrical_affinities_id,
    "title"=paste(contrafacta_and_analogies_with_dates$model_id,"<-->",contrafacta_and_analogies_with_dates$metrical_affinities_id))
  analogies<-na.omit(analogies)
  analogies<-distinct(analogies)
  analogies$dashes<-TRUE
  analogies$arrows="to"
  
  #dataframe of links
  links_vis<-rbind(
    contrafacta,
    analogies
  )
  links_vis$smooth<-TRUE
  
  #dataframe of nodes
  songs<-union(links_vis$from,links_vis$to)
  nodes_vis<-data.frame("id"=songs,"label"=songs)
  
```

Finally, create an interactive visualisation of the network. Songs can be selected by id or by clicking on them. When a song is selected, its neighbours (contrafacta or songs with metrical analogies) are highlighted.  
```{r}
#interactive visuals
  visNetwork(nodes_vis,links_vis)%>%
    visIgraphLayout(layout = "layout_with_fr") %>% 
    visOptions(
      selectedBy = list(
        "variable"="id",
        "highlight"=TRUE
      ), 
      highlightNearest=list(
        "enabled"=TRUE,
        "algorithm"="hierarchical", 
        "degree"=list(from=0,to=1),
        "labelOnly"=FALSE
      )
    ) %>%
    visLayout(randomSeed = 1234)
```

##3. Networks of Authors
###3.1 Nodes

Each node in this temporal network represent the corpus composed by an author. Thus, once an author's node comes into existance, it continues to exist ever since.
In theory, an author's node begin to exist when he starts to compose, that is, the beginning of his activity period. Yet, temporal data about the composition of songs is often uncertain in the BdT. Occasionally, the earliest proposed composition date of a contrafactum in the BdT has been found to preceed the beginning of the activity period of the author of the model. To deal with this uncertainty and ensure that the data on the author's activity period and the data on the composition of a contrafactum/imitation are compatible, the onset of an author's node is fixed at the beginning of the author's period of activity or as the earliest proposed date of composition of a contrafactum/imitation of his work, whichever is earlier.  

```{r}
#extract relevant data
authors_names<-na.omit(unique(c(as.vector(contrafacta_and_analogies_with_dates$model_author),as.vector(contrafacta_and_analogies_with_dates$contrafactum_author),as.vector(contrafacta_and_analogies_with_dates$metrical_affinities_author))))
authors_count<-length(authors_names)
authors_onsets<-numeric(authors_count)
for (j in 1:authors_count){
  authors_onsets[j]<-
    min(
      na.omit(c(
        contrafacta_and_analogies_with_dates$model_onset[contrafacta_and_analogies_with_dates$model_author==authors_names[j]],
        contrafacta_and_analogies_with_dates$contrafactum_onset[contrafacta_and_analogies_with_dates$contrafactum_author==authors_names[j]],
        contrafacta_and_analogies_with_dates$metrical_affinities_onset[contrafacta_and_analogies_with_dates$metrical_affinities_author==authors_names[j]]
      ))
    )
}
authors_terminus<-max(na.omit(c(
  contrafacta_and_analogies_with_dates$model_terminus,
  contrafacta_and_analogies_with_dates$contrafactum_terminus,
  contrafacta_and_analogies_with_dates$metrical_affinities_terminus
)))+1
    
#define author nodes
author_nodes<-data.frame("onset"=authors_onsets,
                             "terminus"=authors_terminus,
                             "vertex.id"=1:authors_count,
                             "onset.censored"=FALSE,
                             "terminus.censored"=FALSE,
                             "duration"=authors_terminus-authors_onsets,
                             "name"=authors_names)
```

###3.2 Links

The presence of a link from node "A" to node "B" means that author "B" has composed a song that is a contrafactum or bears metrical analogies with a song composed by "A". Theoretically, the link should appear exactly when the contrafactum/imitation is composed. Yet, uncertainty in the data means that the composition time is usually given as a range [t1,t2]. The composition time t of the contrafactum has then to be chosen within this interval. The code includes the option to set t=t1, t=(t1+t2)/2 and t=t2. The default is fixed as t=t1.

Occasionally, the earliest proposed composition time t1 of a contrafactum in the BdT has been found to preceed the earliest proposed composition time t1' of its model. This can mean To ensure compatibility, the time of the link is fixed as the latest between these two dates: max(t1,t1'). Note that whilst the choice of the earliest extreme of the interval is somewhat arbitrary, to ensure compatibility, it is important to always take max(t,t') as the time of the link, regardless of how t has been chosen in the interval. See Robustness section for more details.
  
First, we define the links representing the composition of contrafacta only
```{r}
 #links representing the composition of contrafacta only

    #link time options
    #beginning of the interval
    contrafacta_link_time_beginning<-apply(data.frame(
       model_onset=contrafacta_and_analogies_with_dates$model_onset,
      contrafactum_onset=contrafacta_and_analogies_with_dates$contrafactum_onset
    ), 1, max)
      
    #average
    contrafacta_link_time_average<-apply(data.frame(
      model_onset=(contrafacta_and_analogies_with_dates$model_onset+contrafacta_and_analogies_with_dates$model_terminus)/2,
      contrafactum_onset=(contrafacta_and_analogies_with_dates$contrafactum_onset+contrafacta_and_analogies_with_dates$contrafactum_terminus)/2
    ), 1, max)
      
    #end of the interval
    contrafacta_link_time_end<-apply(data.frame(
      model_onset=contrafacta_and_analogies_with_dates$model_terminus,
      contrafactum_onset=contrafacta_and_analogies_with_dates$contrafactum_terminus
    ), 1, max)
   
    #default is fixed as beginning of the interval. UPDATE THIS IF REQUIRED
    contrafacta_link_time<-contrafacta_link_time_beginning
    
    #links dataframe
    contrafacta_links<-data.frame(
      "onset"=contrafacta_link_time,
      "terminus"=contrafacta_link_time,
      "tail"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$model_author,author_nodes$name)],
      "head"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$contrafactum_author,author_nodes$name)],
      "onset.censored"=FALSE,
      "terminus.censored"=FALSE,
      "duration"=authors_terminus-contrafacta_link_time,
      "edge.id"=0,#temporary only
      "tail_label"=contrafacta_and_analogies_with_dates$model_id,
      "tail_onset"=contrafacta_and_analogies_with_dates$model_onset,
      "tail_terminus"=contrafacta_and_analogies_with_dates$model_terminus,
      "head_label"=contrafacta_and_analogies_with_dates$contrafactum_id,
      "head_onset"=contrafacta_and_analogies_with_dates$contrafactum_onset,
      "head_terminus"=contrafacta_and_analogies_with_dates$contrafactum_terminus,
      "repsec"=TRUE
    )
    
    #dataframe cleaning and sorting
    contrafacta_links<-na.omit(contrafacta_links)
    contrafacta_links<-contrafacta_links[order(contrafacta_links$head,contrafacta_links$tail),]
    
    #define link id based on link tail and head
    contrafacta_links_tail_head<-as.character(unique(paste(contrafacta_links$head,contrafacta_links$tail)))
    for (i in 1:length(contrafacta_links_tail_head)){
      contrafacta_links$edge.id[
        paste(
          contrafacta_links$head,
          contrafacta_links$tail)
        ==contrafacta_links_tail_head[i]
        ]<-i
    }
    
    #At the time of writing, tsna cannot deal with multigraphs, so one needs to ensure that at any given time, 
    #any two nodes are connected by at most one link. 
    contrafacta_links<-contrafacta_links[!duplicated(contrafacta_links[c("edge.id","onset")]),]
```

Then, we define the links representing the composition fo a song with metrical analogies
```{r}
#links representing the composition of a song with metrical analogies
    #link time options
    #beginning of the interval
    analogies_link_time_beginning<-apply(data.frame(
      model_onset=contrafacta_and_analogies_with_dates$model_onset,
      analogy_onset=contrafacta_and_analogies_with_dates$metrical_affinities_onset
    ), 1, max)
      
    #average
    analogies_link_time_average<-apply(data.frame(
      model_onset=(contrafacta_and_analogies_with_dates$model_onset+contrafacta_and_analogies_with_dates$model_terminus)/2,
      contrafactum_onset=(contrafacta_and_analogies_with_dates$metrical_affinities_onset+contrafacta_and_analogies_with_dates$metrical_affinities_terminus)/2
    ), 1, max)
      
    #end of the interval
    analogies_link_time_end<-apply(data.frame(
      model_onset=contrafacta_and_analogies_with_dates$model_terminus,
      contrafactum_onset=contrafacta_and_analogies_with_dates$metrical_affinities_terminus
    ), 1, max)
    
    #default is fixed as beginning of the interval. UPDATE THIS IF REQUIRED
    analogies_link_time<-analogies_link_time_beginning
    
    #links dataframe
    analogies_links<-rbind(
      data.frame(
        "onset"=analogies_link_time,
        "terminus"=analogies_link_time,
        "tail"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$model_author,author_nodes$name)],
        "head"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$metrical_affinities_author,author_nodes$name)],
        "onset.censored"=FALSE,
        "terminus.censored"=FALSE,
        "duration"=authors_terminus-analogies_link_time,
        "edge.id"=0,
        "tail_label"=contrafacta_and_analogies_with_dates$model_id,
        "tail_onset"=contrafacta_and_analogies_with_dates$model_onset,
        "tail_terminus"=contrafacta_and_analogies_with_dates$model_terminus,
        "head_label"=contrafacta_and_analogies_with_dates$metrical_affinities_id,
        "head_onset"=contrafacta_and_analogies_with_dates$metrical_affinities_onset,
        "head_terminus"=contrafacta_and_analogies_with_dates$metrical_affinities_terminus,
        "repsec"=FALSE
      ),
      data.frame("onset"=analogies_link_time,
                 "terminus"=analogies_link_time,
                 "tail"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$metrical_affinities_author,author_nodes$name)],
                 "head"=author_nodes$vertex.id[match(contrafacta_and_analogies_with_dates$model_author,author_nodes$name)],
                 "onset.censored"=FALSE,
                 "terminus.censored"=FALSE,
                 "duration"=analogies_link_time,
                 "edge.id"=0,
                 "tail_label"=contrafacta_and_analogies_with_dates$metrical_affinities_id,
                 "tail_onset"=contrafacta_and_analogies_with_dates$metrical_affinities_onset,
                 "tail_terminus"=contrafacta_and_analogies_with_dates$metrical_affinities_terminus,
                 "head_label"=contrafacta_and_analogies_with_dates$model_id,
                 "head_onset"=contrafacta_and_analogies_with_dates$model_onset,
                 "head_terminus"=contrafacta_and_analogies_with_dates$model_terminus,
                 "repsec"=FALSE
      )
    )
    
    #dataframe cleaning and sorting
    all_links<-rbind(na.omit(contrafacta_links),na.omit(analogies_links))
    all_links<-all_links[order(all_links$head,all_links$tail),]
    
    #define edge id
    all_links_tail_head<-as.character(unique(paste(all_links$head,all_links$tail)))
    for (i in 1:length(all_links_tail_head)){
      all_links$edge.id[
        paste(
          all_links$head,
          all_links$tail)
        ==all_links_tail_head[i]
        ]<-i
    }
    #At the time of writing, tsna cannot deal with multigraphs, so one needs to ensure that at any given time, 
    #any two nodes are connected by at most one link. 
    all_links<-all_links[!duplicated(all_links[c("edge.id","onset")]),]
```


###3.3 Static Networks

Before we construct the temporal network, we need static networks: one containing the links due to contracta only and one containing contrafacta and as well as more general metrical analogies.
```{r}
#contrafacta only
contrafacta_static<-network(
      data.frame("tail"=contrafacta_links$tail,"head"=contrafacta_links$head),
      directed = TRUE,
      multiple = FALSE,
      bipartite = FALSE
    )

#all links
all_static<-network(
      data.frame("tail"=all_links$tail,"head"=all_links$head),
      directed = TRUE,
      multiple = FALSE,
      bipartite = FALSE
    )
```


###3.4 Temporal Networks

We can now construct the temporal networks:  one containing the links due to contracta only and one containing contrafacta and as well as more general metrical analogies.

Contrafacta only:
```{r}
#make temporal network 
contrafacta_dynamic <- networkDynamic(
    contrafacta_static,
    edge.spells = data.frame("onset"=contrafacta_links$onset,
                             "terminus"=contrafacta_links$terminus,
                              "tail verted.id"=contrafacta_links$tail,
                             "head vertex.id"=contrafacta_links$head
     ),
    vertex.spells = data.frame("onset"=author_nodes$onset,
                               "terminus"=author_nodes$terminus,
                               "vertex.id"=author_nodes$vertex.id
     )
  )
      
#check correctness
network.dynamic.check(contrafacta_dynamic)
```
Contrafacta and analogies:
```{r}
#make temporal network 
all_dynamic <- networkDynamic(
        all_static,
        edge.spells = data.frame("onset"=all_links$onset,
                                 "terminus"=all_links$terminus,
                                 "tail verted.id"=all_links$tail,
                                 "head vertex.id"=all_links$head
        ),
        vertex.spells = data.frame("onset"=author_nodes$onset,
                                   "terminus"=author_nodes$terminus,
                                   "vertex.id"=author_nodes$vertex.id
        )
      )
      
      
#check
network.dynamic.check(all_dynamic)
```

Example of application: comptute forward and backward reachability
```{r}
#contrafacta only 
fwd_reach_contrafacta_only <- tReach(contrafacta_dynamic)
bkwd_reach_contrafacta_only <- tReach(contrafacta_dynamic, direction = "bkwd")
#save as dataframe
contrafacta_fwd_bkwd<-data.frame("fwd"=fwd_reach_contrafacta_only,"bkwd"=bkwd_reach_contrafacta_only,"author_name"=authors_names)

#all links
fwd_reach_all_contrafacta <- tReach(all_dynamic)
bkwd_reach_all_contrafacta <- tReach(all_dynamic, direction = "bkwd")
#save as dataframe
all_fwd_bkwd<-data.frame("fwd"=fwd_reach_all_contrafacta,"bkwd"=bkwd_reach_all_contrafacta,"author_name"=authors_names)
```

###3.5 Analysis and Visuals
We can finally compute node-related measures for our temporal networks and create visualisations to assist their analysis.

####3.5.1 Animated plots
First, we create animated plots that show when links are created.

Contrafacta only:
```{r}
#calculate how to plot animated version
      compute.animation(
        contrafacta_dynamic,
        animation.mode = "kamadakawai",
        slice.par = list(
          start = 1130,
          end = 1332,
          interval = 10,
          aggregate.dur = 20,
          rule = "latest"
        )
      )
      
      #Render the animation and open it in a web brower
      render.d3movie(
        contrafacta_dynamic,
        displaylabels = FALSE,
        output.mode = 'htmlWidget'
      )
```
Contrafacta and analogies:
```{r}
 #calculate how to plot animated version
      compute.animation(
        all_dynamic,
        animation.mode = "kamadakawai",
        slice.par = list(
          start = 1190,
          end = 1332,
          interval = 5,
          aggregate.dur = 5,
          rule = "latest"
        )
      )
      
      #Render the animation and open it in a web brower
      render.d3movie(
        all_dynamic,
        displaylabels = FALSE,
        output.mode = 'htmlWidget',#,
        #This slice function makes the labels work
        vertex.tooltip = function(slice) {
          paste(
            "<b>ID:</b>", (slice %v% "name"))
        }
      )
```

####3.5.2 Compare forward and backward reachability
The following code generates plot comparing the forward and backward reachability of each author. Authors with exceptionally large forward or backward reachability are labelled for convenience.

Contrafacta only:
```{r}
 ggplot(contrafacta_fwd_bkwd, aes(x=fwd,y=bkwd))+
      geom_point(color="black", position = "jitter")+#, size=sqrt(data$count)*2)+
      geom_label_repel(
        data=contrafacta_fwd_bkwd %>% filter(fwd>60 | bkwd>27 | (fwd>27 & bkwd>10)),
        aes(label=author_name),
        #nudge_x = 1, nudge_y = 0.5, 
        check_overlap = T
      )+
      theme_ipsum(
        axis_title_size = 12,
        axis_text_size = 11,
        plot_margin = margin(0, 0, 0, 0),
        grid_col = "#cccccc",
        grid = TRUE,
        axis_col = "#000000",
        axis = TRUE,
        ticks = FALSE
      )+
      theme(
        plot.title = element_text(size=15),
        axis.title = element_text(size=10,vjust=0.5),
        panel.grid.major.x=element_blank(),
        panel.grid.minor.x=element_blank()
      ) +
      ggtitle("Backward- vs Forward-Reachable Sets (Contrafacta)")+
      ylab("size of backward-reachable set")+
      xlab("size of forward-reachable set")+
      scale_x_continuous(breaks=seq(0,130,by=10))
```
Contrafacta and analogies:
```{r}
ggplot(all_fwd_bkwd, aes(x=fwd,y=bkwd))+
      geom_point(color="black", position = "jitter")+
      geom_label_repel(
        data=all_fwd_bkwd %>% filter(fwd>265 | bkwd>90 | (fwd>250 & bkwd>70)),
        aes(label=author_name),
        #nudge_x = 1, nudge_y = 0.5, 
        check_overlap = T
      )+
      theme_ipsum(
        axis_title_size = 12,
        axis_text_size = 11,
        plot_margin = margin(0, 0, 0, 0),
        grid_col = "#cccccc",
        grid = TRUE,
        axis_col = "#000000",
        axis = TRUE,
        ticks = FALSE
      )+
      theme(
        plot.title = element_text(size=15),
        axis.title = element_text(size=10,vjust=0.5),
        panel.grid.major.x=element_blank(),
        panel.grid.minor.x=element_blank()
      ) +
      ggtitle("Backward- vs Forward-Reachable Sets (Contrafacta and Analogies)")+
      ylab("size of backward-reachable set")+
      xlab("size of forward-reachable set")+
      scale_x_continuous(breaks=seq(0,270,by=15))
```


####3.5.3 Network visualisation and analysis function
The following function can be used for both analysis and visualisation. It uses igraph for the graph analysis and visNetwork for its visualisation
The function takes 4 arguments:

1. analogies: TRUE/FALSE whether to include analogies links in the network or not (just contrafacta).
    
2. type_size: the measure to be represented as node size. For possible measures, see below.
    
3. type_colour: the measure to be represented as node colour For measures, see below.
    
4. visual: TRUE/FALSE whether the result should be a plot or a dataframe with the required measures. The FALSE option is helpful for saving data for future analysis. 
    
Possible choices of measures: 

1. "in degree"
    
2. "out degree"
    
3. "betweenness static", i.e. the betweenness computed ignoring temporal information
    
4. "betweenness dynamic", i.e. the betweenness computed including temporal information
    
5. "closeness static"
    
6. "closeness dynamic"
    
7. "reachable", i.e. the size of the forward reachability set ignoring tempporal information
    
8. "temporal reachable" i.e. the size of the forward reachability set including tempporal information
    
Remark: The computation of the betweenness dynamic is quite slow. It might take a few minutes.

First, define helpful links dataframes (this alternative format is required when using igraph)
```{r}
#contrafacta only
contrafacta_links_2<-data.frame(
    "from"=contrafacta_links$tail,
    "to"=contrafacta_links$head,
    "head_label"=contrafacta_links$head_label,
    "head_onset"=contrafacta_links$head_onset,
    "head_terminus"=contrafacta_links$head_terminus,
    "tail_label"= contrafacta_links$tail_label,
    "tail_onset"=contrafacta_links$tail_onset,
    "tail_terminus"=contrafacta_links$tail_terminus,
    "dashes"=!contrafacta_links$repsec)
#clean dataframe and add labels
contrafacta_links_2<-na.omit(contrafacta_links_2)
contrafacta_links_2<-distinct(contrafacta_links_2,from,to,head_label,tail_label,.keep_all = TRUE)
contrafacta_links_2$title<-paste(contrafacta_links_2$tail_label,
                                    " (",
                                    contrafacta_links_2$tail_onset,
                                    "-",
                                    contrafacta_links_2$tail_terminus,
                                    ")->",
                                    contrafacta_links_2$head_label,
                                    " (",
                                    contrafacta_links_2$head_onset,
                                    "-",
                                    contrafacta_links_2$head_terminus,
                                    ")",sep="")
contrafacta_links_2$arrows<-"to"

#contrafacta and metrical analogies  
all_links_2<-data.frame(
    "from"=all_links$tail,
    "to"=all_links$head,
    "head_label"=all_links$head_label,
    "head_onset"=all_links$head_onset,
    "head_terminus"=all_links$head_terminus,
    "tail_label"= all_links$tail_label,
    "tail_onset"=all_links$tail_onset,
    "tail_terminus"=all_links$tail_terminus,
    "dashes"=!all_links$repsec)
all_links_2<-na.omit(all_links_2)
all_links_2<-distinct(all_links_2,from,to,head_label,tail_label,.keep_all = TRUE)
all_links_2$title<-paste(all_links_2$tail_label,
                                 " (",
                                 all_links_2$tail_onset,
                                 "-",
                                 all_links_2$tail_terminus,
                                 ") ->",
                                 all_links_2$head_label,
                                 " (",
                                 all_links_2$head_onset,
                                 "-",
                                 all_links_2$head_terminus,
                                 ")",sep="")
all_links_2$arrows="to"
```

Finally, the function
```{r}
 final_network_with_colour<-function(analogies,type_size,type_colour,visual){
      #define nodes
      {
        nodes_vis<-data.frame(id=author_nodes$vertex.id,label=author_nodes$name)
      }
      #define edges
      {
        if(analogies){
          edges_vis<-all_links_2
          static_network<-all_static
          dynamic_network<-all_dynamic
          
        }else{
          edges_vis<-contrafacta_links_2
          static_network<-contrafacta_static
          dynamic_network<-contrafacta_dynamic
        }
        edges_vis$smooth<-FALSE
      }
      #define igraph object
      {
        static_network_igraph<-graph_from_data_frame(edges_vis, directed = TRUE, vertices=nodes_vis)
      }
      #compute node measures
      {
        if (type_size=="in degree"|| type_colour=="in degree"){
          nodes_vis$in_degree<-igraph::degree(static_network_igraph,mode="in")
        }
        if (type_size=="out degree" || type_colour=="out degree") {
          nodes_vis$out_degree<-igraph::degree(static_network_igraph,mode="out")
        }
        if (type_size=="betweenness static" || type_colour=="betweenness static"){
          nodes_vis$betweenness_static<-betweenness(static_network)/max(betweenness(static_network))*50
        }
        if (type_size=="betweenness dynamic" || type_colour=="betweenness dynamic"){
          #temporal betweenness function
          {
            #inputs: a starting node i and a final node j
            #outputs: number of temporally valid paths from i to j and the number of such paths passing through author/node k for each author
            n_paths_from_i_to_j<-function(i,j){
              #find all paths in from i to j
              all_paths<-all_shortest_paths(static_network_igraph,from=i,to=j)$res
              valid_paths<-list()
              valid_paths_with_k<-numeric(authors_count)
              n=1
              #for each path, verify that the path is temporally valid 
              #i.e., if the time of appearance of the directed links along the path is sorted
              for (p in all_paths) {
                p_data_frame<-data.frame(
                  from=as.numeric(p[1:(length(p)-1)]),
                  to=as.numeric(p[2:(length(p))])
                ) 
                p_data_frame<-join(p_data_frame,edges_vis,by=c("from","to"))
                p_valid<-!is.unsorted(p_data_frame$onset)
                #for each valid path, check if it passes through author/node k
                if(p_valid){
                  valid_paths[[n]]<-p
                  n<-n+1
                  for (k in 1:authors_count){
                    valid_paths_with_k[k]<-ifelse(k %in% p, valid_paths_with_k[k]+1,valid_paths_with_k[k])
                  }
                }
              }
              valid_and_k_valid<-list("valid"=length(valid_paths),"k_valid"=valid_paths_with_k)
              return(valid_and_k_valid)
            }
          }
          #computation
          {
            #initialise matrices
            n_paths_ijk<-array(NA,dim=c(authors_count,authors_count,authors_count))
            n_paths_ij<-matrix(NA,nrow=authors_count,ncol=authors_count)
            
            #find number of valid paths for each apir (i,j) and for all values of k
            for (i in 1:authors_count) {
              for (j in 1:authors_count) {
                if (!i==j){
                  paths_info_ij<-n_paths_from_i_to_j(i,j)
                  n_paths_ij[i,j]<-paths_info_ij$valid
                  n_paths_ijk[i,j,]<-paths_info_ij$k_valid
                }
              }
              print(i)
            }
            
            #compute betweenness for each value k
            temporal_betwenness_values<-numeric(authors_count)
            diag(n_paths_ij)<-1
            for (k in 1:authors_count){
              n_paths_ij_k<-n_paths_ij
              n_paths_ijk_k<-n_paths_ijk[,,k]
              diag(n_paths_ijk_k)<-0
              n_paths_ijk_k<-n_paths_ijk_k[-k,-k]
              n_paths_ij_k<-n_paths_ij_k[-k,-k]
              ratio_matrix<-n_paths_ijk_k/n_paths_ij_k
              temporal_betwenness_values[k]<-sum(ratio_matrix,na.rm=TRUE)
            }
          }
          #assign betweenness to each node
          nodes_vis$betweenness_dynamic<-temporal_betwenness_values
        }
        if (type_size=="closeness static" || type_colour=="closeness static"){
          out_harmon_static<-numeric(authors_count)
          static_network_distances<-distances(static_network_igraph, v = V(static_network_igraph), to = V(static_network_igraph), mode = "out", weights = NULL, algorithm = "dijkstra")
          for(i in 1:authors_count){
            out_harmon_static[i]<-sum(1/static_network_distances[i,-i])
          }
          nodes_vis$out_harmonic_closeness_static<-out_harmon_static
        }
        if (type_size=="closeness dynamic" || type_colour=="closeness dynamic"){
          out_harmon_dynamic<-numeric(312)
          dynamic_network_distances<-matrix(NA,nrow=312,ncol=312)
          for (i in 1:312){
            dynamic_network_distances[i,]<-tPath(dynamic_network, v = i,direction ="fwd")$gsteps
          }
          for(i in 1:312){
            out_harmon_dynamic[i]<-sum(1/dynamic_network_distances[i,-i])
          }
          nodes_vis$out_harmonic_closeness_dynamic<-out_harmon_dynamic
        }
        if (type_size=="reachable" || type_colour=="reachable"){
          nodes_vis$reachable_set_size<-rowSums(reachability(static_network))
        }
        if (type_size=="temporal reachable" || type_colour=="temporal reachable"){
          nodes_vis$temporal_reachable_set_size<-tReach(dynamic_network)
        }
      }
      #visuals
      {
        set.seed(1234)
        colfunc<-colorRampPalette(c("#333333",ifelse(analogies,"orange","red"),"white"))
        highlightnearestvalues<-list(
          "enabled"=TRUE,
          "algorithm"="hierarchical", 
          "degree"=list(from=0,to=0),
          "labelOnly"=FALSE
        )
        
        if (type_colour=="none"){
          nodes_vis$color<-"black"
        }
        else if (type_colour=="in degree"){
          color_distance<-colfunc(max(nodes_vis$in_degree)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$in_degree)+1]
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=1,to=0),
            "labelOnly"=FALSE
          )
        }
        else if (type_colour=="out degree"){
          color_distance<-colfunc(max(nodes_vis$out_degree)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$out_degree)+1]
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=0,to=1),
            "labelOnly"=FALSE
          )
        }
        else if (type_colour=="betweenness static"){
          color_distance<-colfunc(max(nodes_vis$betweenness_static)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$betweenness_static)+1]
        }
        else if (type_colour=="betweenness dynamic"){
          color_distance<-colfunc(max(nodes_vis$betweenness_dynamic)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$betweenness_dynamic)+1]
        }
        else if (type_colour=="closeness static"){
          color_distance<-colfunc(max(nodes_vis$out_harmonic_closeness_static)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$out_harmonic_closeness_static)+1]
        }
        else if (type_colour=="closeness dynamic"){
          color_distance<-colfunc(max(nodes_vis$out_harmonic_closeness_dynamic)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$out_harmonic_closeness_dynamic)+1]
        }
        else if (type_colour=="reachable"){
          color_distance<-colfunc(max(nodes_vis$reachable_set_size)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$reachable_set_size)+1]
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=0,to=12),
            "labelOnly"=FALSE
          )
        }
        else if (type_colour=="temporal reachable"){
          color_distance<-colfunc(max(nodes_vis$temporal_reachable_set_size)+1)
          nodes_vis$color<-color_distance[floor(nodes_vis$temporal_reachable_set_size)+1]
        }
        
        if (type_size=="none"){
          nodes_vis$value<-1
        }
        else if (type_size=="in degree"){
          nodes_vis$value<-nodes_vis$in_degree+1
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=1,to=0),
            "labelOnly"=FALSE
          )
        }
        else if (type_size=="out degree"){
          nodes_vis$value<-nodes_vis$out_degree+1
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=0,to=1),
            "labelOnly"=FALSE
          )
        }
        else if (type_size=="betweenness static"){
          nodes_vis$value<-floor(nodes_vis$betweenness_static)+1
        }
        else if (type_size=="betweenness dynamic"){
          nodes_vis$value<-floor(nodes_vis$betweenness_dynamic)+1
        }
        else if (type_size=="closeness static"){
          nodes_vis$value<-floor(nodes_vis$out_harmonic_closeness_static)+1
        }
        else if (type_size=="closeness dynamic"){
          nodes_vis$value<-floor(nodes_vis$out_harmonic_closeness_dynamic)+1
        }
        else if (type_size=="reachable"){
          nodes_vis$value<-floor(nodes_vis$reachable_set_size)+1
          highlightnearestvalues<-list(
            "enabled"=TRUE,
            "algorithm"="hierarchical", 
            "degree"=list(from=0,to=12),
            "labelOnly"=FALSE
          )
        }
        else if (type_size=="temporal reachable"){
          nodes_vis$value<-floor(nodes_vis$temporal_reachable_set_size)+1
        }
        
        p<-visNetwork(nodes_vis,edges_vis)%>%
          visIgraphLayout(layout = "layout_with_fr") %>% 
          visOptions(
            selectedBy = list(
              "variable"="label",
              "highlight"=TRUE
            ), 
            highlightNearest=highlightnearestvalues
          ) %>%
          visLayout(randomSeed = 1234)
        if(visual){         
          return(p)
        }
        else {
          return(nodes_vis)
        }
      }
    }
```

Here are a few example of the visuals:

1) All links, size of the node is its out-degree, colour is its in-degree
```{r}
final_network_with_colour(TRUE,"out degree","in degree",TRUE)
```
2) All links, size of the node is its out-degree, colour is its temporal reachability
```{r}
final_network_with_colour(TRUE,"out degree","temporal reachable",TRUE)
```
3) All links, size of the node is its reachability, ignoring temporal information, colour is its temporal reachability
```{r}
final_network_with_colour(TRUE,"reachable","temporal reachable",TRUE)
```
4) Contrafacta only, size of the node is its out-degree, colour is its in-degree
```{r}
final_network_with_colour(FALSE,"out degree","in degree",TRUE)
```
5) All links, size of the node is its betweenness, colour is its closeness, both computed taking temporal information info account
```{r}
final_network_with_colour(TRUE,"betweenness dynamic","closeness dynamic",TRUE)
```

####3.5.4 Author reachability
The following function allows to visualise the temporally consistent paths in the network starting from or ending in a node. These represent the authors who might have influenced or might have been influenced by a given author.

The function takes as inputs:

1. author: an author's name or id,

2. analogies: TRUE/FALSE, whether analogies should be included or only contrafacta,

3. temporal: TRUE/FALSE if temporally consistent paths only should be considered,

4. forward: TRUE/FALSE if forward paths or backward paths should be considered.

```{r}
path_by_author=function(author,analogies,temporal,forward){
        #define nodes
        {
          nodes_vis<-data.frame(id=author_nodes$vertex.id,label=author_nodes$name)
        }
        #define edges
        {
          if(analogies){
            edges_vis<-all_links_2
            static_network<-all_static
            dynamic_network<-all_dynamic
          }else{
            edges_vis<-contrafacta_links_2
            static_network<-contrafacta_static
            dynamic_network<-contrafacta_dynamic
          }
          edges_vis$smooth<-TRUE
        }
        #define igraph object and compute distances
        {
          static_network_igraph<-graph_from_data_frame(edges_vis, directed = TRUE, vertices=nodes_vis)
          static_distances<-distances(static_network_igraph, v = V(static_network_igraph), to = V(static_network_igraph), mode = "out", weights = NULL, algorithm = "dijkstra")
        }
        #find id if author given as name
        {
          author_id<-ifelse(is.numeric(author),author,author_nodes$vertex.id[author_nodes$name==author])
          author_id<-as.numeric(author_id)
        }
        #define group
        {
          if (temporal){
            if(forward){
              nodes_steps<-tPath(
                dynamic_network,
                v = author_id,
                direction ="fwd"
              )$gsteps
            } else {
              nodes_steps<-tPath(
                dynamic_network,
                v = author_id,
                direction ="bkwd",
                type="latest.depart"
              )$gsteps
            }
            nodes_vis$group<-as.character(nodes_steps) 
          }else{
            nodes_vis$group<-as.character(as.vector(static_distances[author_id,]))
          }
        }
        #visuals
        {
          colfunc<-colorRampPalette(c("white",ifelse(analogies,"orange","red"),"black"))
          color_distance<-colfunc(10)
          set.seed(1234)
          
          visNetwork(nodes_vis,edges_vis)%>%
            visIgraphLayout(layout = "layout_with_fr") %>% 
            visGroups(groupname = "0",color=color_distance[1]) %>%
            visGroups(groupname = "1",color=color_distance[2]) %>%
            visGroups(groupname = "2", color=color_distance[3])%>%
            visGroups(groupname = "3", color=color_distance[4])%>%
            visGroups(groupname = "4", color=color_distance[5])%>%
            visGroups(groupname = "5", color=color_distance[6])%>%
            visGroups(groupname = "6", color=color_distance[7])%>%
            visGroups(groupname = "7", color=color_distance[8])%>%
            visGroups(groupname = "8", color=color_distance[9])%>%
            visGroups(groupname = "9", color=color_distance[10])%>%
            visGroups(groupname = "Inf", color="#333333")%>%
            visOptions(
              selectedBy = list(
                "variable"="label",
                "highlight"=TRUE
              ), 
              highlightNearest=list(
                "enabled"=TRUE,
                "algorithm"="hierarchical", 
                "degree"=list(from=0,to=0),
                "labelOnly"=FALSE
              )
            ) %>%
            visLayout(randomSeed = 1234)
        }
        
      }
```

Example: termporally consistent forward paths for Elias de Barjols, including analogies as well as contrafacta.
```{r}
path_by_author("Elias de Barjols",TRUE,TRUE,TRUE)
```

###3.6 Robustness of the analysis 

There is considerable uncertainty regarding the time of composition of a contrafactum or other imitation. The composition time is generally given as an interval [t1,t2] in the BdT and a choice has to be made about what value t in [t1,t2] should be taken as the onset time of the links in the temporal networks. 
This code shows the degree distribution and the reachability sets obtained when t is chosen to be t=t1, t=(t1+t2)/2, or t=t2. Although differences are visible, the correlation between the degree distributions as well as the correlation of the size of the reachability sets obtained when comparing any two of these choices is very high and significant. This indicates that the analysis is robust.  

```{r}
  #degree data
  contrafacta_degree_beginning<-read.csv("./robustness_results/contrafacta_degree_beginning.csv",stringsAsFactors = FALSE)
  all_degree_beginning<-read.csv("./robustness_results/all_degree_beginning.csv",stringsAsFactors = FALSE)
  
  contrafacta_degree_average<-read.csv("./robustness_results/contrafacta_degree_average.csv",stringsAsFactors = FALSE)
  all_degree_average<-read.csv("./robustness_results/all_degree_average.csv",stringsAsFactors = FALSE)
  
  contrafacta_degree_end<-read.csv("./robustness_results/contrafacta_degree_end.csv",stringsAsFactors = FALSE)
  all_degree_end<-read.csv("./robustness_results/all_degree_end.csv",stringsAsFactors = FALSE)
  
  #example correlation tests
  cor.test(contrafacta_degree_beginning$in_degree, contrafacta_degree_average$in_degree, method = c("pearson", "kendall", "spearman"))
  
  #fwd/bkwd paths data
  contrafacta_fwd_bkwd_beginning<-read.csv("./robustness_results/contrafacta_fwd_bkwd_beginning.csv")
  all_fwd_bkwd_beginning<-read.csv("./robustness_results/all_fwd_bkwd_beginning.csv")
  
  contrafacta_fwd_bkwd_average<-read.csv("./robustness_results/contrafacta_fwd_bkwd_average.csv")
  all_fwd_bkwd_average<-read.csv("./robustness_results/all_fwd_bkwd_average.csv")
  
  contrafacta_fwd_bkwd_end<-read.csv("./robustness_results/contrafacta_fwd_bkwd_end.csv")
  all_fwd_bkwd_end<-read.csv("./robustness_results/all_fwd_bkwd_end.csv")
  
  #example correlation tests
  cor.test(contrafacta_fwd_bkwd_beginning$fwd, contrafacta_fwd_bkwd_average$fwd, method = c("pearson", "kendall", "spearman"))
  cor.test(contrafacta_fwd_bkwd_beginning$fwd, contrafacta_fwd_bkwd_end$fwd, method = c("pearson", "kendall", "spearman"))
  cor.test(all_fwd_bkwd_beginning$fwd, all_fwd_bkwd_average$fwd, method = c("pearson", "kendall", "spearman"))
  cor.test(all_fwd_bkwd_beginning$fwd, all_fwd_bkwd_end$fwd, method = c("pearson", "kendall", "spearman"))
  
  #example correlation plots
  my_data<-data.frame("fwd1"=contrafacta_fwd_bkwd_beginning$fwd,"fwd2"=contrafacta_fwd_bkwd_end$fwd)
  ggscatter(my_data, x = "fwd1", y = "fwd2", 
            add = "reg.line", conf.int = TRUE, 
            cor.coef = TRUE, cor.method = "pearson",
            xlab = "fwd_reachability", ylab = "fwd_reachability")

```
